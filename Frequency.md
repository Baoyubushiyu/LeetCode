- *代表需要重视的程度
- 重视的题型：排列组合

# Medium
## 1. 两数之和
求数组内=target的元素下标，HashMap

## 3. 无重复字符的最长子串
使用boolean[] 256做hash桶，使用双指针，前指针往前移填充hash，发现重复的话（更新结果），后指针前移，擦除hash，循环检查前指针指向的字符是否重复，重复就后指针前移，不重复就前指针前移。

## 5. **最长的回文子串
DP, 二维DP，填左半边，从下往上，从左往右 子串 dp[i, j] = (char_i == char_j) && dp[i+1, j-1]
```Java
for (int i = len-1; i >= 0; i--) {
    for (int j = i+1; j < len; j++) {
        if (s.charAt(i) == s.charAt(j) && (i+1 > j-1 || dp[i+1][j-1])) {
            dp[i][j] = true;
            if (j-i+1 > longest) {
                longest = j - i + 1;
                start = i;
            }
        }
    }
}
```
## 6. Z字形变换
Z字形（从上到下，从左到右排列字符串，然后按行收集），关键：控制打印方向 flag 

## 7. 整数反转
直接使用取余即可，不用区分正数负数，负数对10取余，是末尾的数字加个负号（Java是截断除法），判断溢出可以判断在ret*10+last前面判断与MAX_VALUE/10的关系。

## 8. atoi字符串转整数（未做）
溢出需要全面考虑

## 9. 回文数
不将整数转化成字符串，按照第7题，将数字反转，看看是否和原数字一样。

## 11. *盛最多水的容器
双指针，头尾各一个指针，一开始宽是最长的，所以移动短的那一端，高才有可能增加，进而面积才有可能增加。

## 12. 13 罗马数字和整型的互相转化（未做）

## 14. 最长的公共前缀
字符串数组中的最长公共前缀。很简单，索引从0开始到 最短字符串的长度len，然后遍历每个串，求当前索引位置的字符是否都相等，遇到不相等的，直接返回（公共前缀就到此）。

## 15. 三数之和
固定一个数字，然后就转化成了两数之和问题，可以使用排序+双指针写法；或者使用Hash方法。

## 16. 最接近的三数之和
双指针，和上题基本一样，固定一个数字，然后头尾双指针移动，双指针移动的方法也一样，只不过就是在内部要更新一下接近值。

## 17. *电话号码的字母组合

## 18. 四数之和（哈希）
三数之和升级版，就是在三数之和的基础之上多加了一层循环，前面循环两个数，然后最后变成两数之和。

## 19. 删除链表倒数第N个结点（双指针）
一个指针先走N步，然后另一个指针开始走，第一个指针走到头，第二个指针指向的位置就是倒数第N个结点。不用非得
```Java
while (fast.next != null) {
    if (n <= 0) slow = slow.next;
    fast = fast.next;
    n--;
}
slow.next = slow.next.next;
```
## 20. 有效的括号（栈）
使用栈，遍历当前字符，是)]}时候，pop出栈顶元素，查看是否匹配；是([{括号入栈。

## 21. 合并两个有序链表（归并）
归并算法

## 22. 括号生成（回溯、DFS）
生成n对合法的括号字符串（括号匹配），可以组成有效括号重点是：左右括号的数目
> 非常优秀的一道回溯、DFS类题目，对于排列组合类的回溯，还需多练习。
```Java
private void dfs(int n, int l, int r, String cur, List<String> ret) {
    if (cur.length() == 2*n) {
        ret.add(cur);
        return;
    }
    if (l < n) {
        dfs(n, l+1, r, cur+'(', ret);
    }
    if (r < l) {
        dfs(n, l, r+1, cur+')', ret);
    }
}
```
## 23. 合并K个链表（归并、堆）
使用大小为K的堆，找到最小的点，链接到结果链表，然后此节点的下一个节点加入堆（此处也是以前没有想到的地方）

## 24. ***两两交换链表节点（链表）
有一个指向前面的p, 然后q 和 q.next是要交换的两个，但是也要注意p要指向q.next。
```Java
public ListNode swapPairsNew(ListNode head) {
    ListNode dummy = new ListNode(-1);
    dummy.next = head;
    ListNode p = dummy, q = head;
    while (q != null && q.next != null) {
        p.next = q.next;
        q.next = q.next.next;
        p.next.next = q;
        // 更新 p 和 q
        p = q;
        q = q.next;
    }
    return dummy.next;
}
// 不要和 字符串翻转 代码搞混了
public ListNode swapPairsRecursive(ListNode head) {
    if(head == null || head.next == null) return head;
    ListNode nextNode = head.next;
    head.next = swapPairsRecursive(nextNode.next);
    nextNode.next = head;
    return nextNode;
}
```
## 25. ***K个一组，反转链表（链表）
```Java
// 翻转链表 递归写法
private ListNode reverse2(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode newHead = reverse2(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```
## 26. **删除排序数组中的重复项(数组)
数组，去除重复项后,原地修改数组，前面都是非重复的元素，返回长度。 
这种重复的要考虑相邻的元素是否相等。

## 27. ***移除元素（数组，多解法）
1. 要移除的元素多
保留的少，那么就挑选出要保留的元素，从前往后放置
```Java
public int removeElement(int[] nums, int val) {
    int ans = 0;
    for(int num: nums) {
        if(num != val) {
            nums[ans] = num;
            ans++;
        }
    }
    return ans;
}
```
2. 要移除的元素少
保留的多，那么就将要移除的挪到后面去，要保留的从后往前挪到前面去。
```Java
class Solution {
    public int removeElement(int[] nums, int val) {
        int ans = nums.length;
        for (int i = 0; i < ans;) {
            if (nums[i] == val) {
                // 不用找特定的位置再挪，一个一个挪过去就行，也可以循环找到位置
                nums[i] = nums[--ans];
            } else {
                i++;
            }
        }
        return ans;
    }
}
```
## 28. strStr()
Sunday算法

## 29. 两数相除

## 31. **下一个排列（规则，数组）
数组数字序列，下一个更大的排列。
思路：从后往前找到arr[i-1] < arr[i]的位置，然后找到后面第一个比arr[i-1]大的位置，两个位置交换，然后 i-1往后的元素（从大到小排列的），逆序即可.

## 33. 搜索旋转排序数组（二分查找）
根据num[l] 与num[m]的关系

## 35. 搜索插入位置（二分）
二分查找，注意初始值（和边界值有关），以及如何判断边界值

## 36. 有效的数独（哈希）
判断一个数独（没有数字的部分使用'.'来填充）是否有效（三种规则行1-9、列1-9，3X3格子1-9）。
解法：使用三个hash表（Hash表使用长度为10的boolean数组），一次遍历即可，特别要注意的是3X3格子的下标转换。

## 38. 外观数列（数组）
从前往后读前一个字符串连续数目、数字，追加到结果中。 求连续的数目，最好的办法是判断 `j == j+1` 是否成立.

## 39. 组合总和（回溯）
一个数组能组成target的所有组合，不要重复，每个数字可以用多次。
典型的回溯，因为要求**所有**组合！是一个枚举所有情况的过程。

## 40. 组合总和2（回溯）
在39题的基础之上，每个数字只能使用一次。
难点：如何去重。方案：排序，判断数组中当前（要添加到结果集）的元素和前一个是否是相等的？
回溯中有两个逻辑

## 41. 缺失的第一个正数
给你一个未排序的整数数组（可能存在负整数），请你找出其中没有出现的最小的正整数。
思路：最小整数是 <= 数组的长度n的，，并且还是正整数，所以就想到了数组的下标，在数组下标身上进行标记。将数组中<=0的数字使用n+1进行替换，然后遍历数组，绝对值<=n的，数组中对应的元素（若为正）换成负数。

## 42. 接雨水（双指针）
木桶原理，每一个柱体可以接雨水，由它的左边和右边的最大值的最小值来决定的。我们可以求每一个柱体的这个值，左遍历一遍，右遍历一遍即可。
我们可以使用双指针进行优化, 小的那一边进行移动，然后不断的更新小的那一边的max值，最终结果不断的累加max-cur的。

## 43. 字符串相乘(大数乘法)
竖式模拟乘法，可以找规律：最终结果最多 len1+len2位；str1[i] * str2[j]，获得的局部结果在第ret[i+j]和ret[i+j+1]位置。
难点：如何将这些局部的值加在一起? 就是从后往前计算，在计算每个局部和 sum = str1[i] * str2[j]+ret[i+j+1]， ret[i+j+1] = sum % 10; ret[i+j] += sum /10; 注意去除前导0，和结果仅为0的情况。

## 45. *跳跃游戏2（贪心）
问至少多少次可以跳到末尾，贪心算法，每次跳到所能触及到的最远位置，

## 46. 全排列（回溯）
求没有重复的数组的去排列。
回溯，还有used数组，套模板即可。

## 47. 全排列2 (回溯)
和上题一样，但是难点：如何解决重复? 对数组预先排序，对于重复的元素，只使用第一个元素。
`if (i > 0 && num[i] == num[i-1] && !used[i-1]) continue;` 
如果used[i-1]没有被使用，那么后续肯定会被使用，就会导致重复。

## 48. 旋转图像
原地顺时针旋转90度，左上和右下进行交换，然后再上下交换。

> 原地修改的算法，一般思路是：交换、做标记（加正负号、bit位做标记）

## 49. 字母异位词分组
将排序后的字符串作为识别的key，添加到map的集合中。 如何避免排序，可以自己统计每种字母的情况，然后组成特殊的字符串当成map的key
```Java
char[] chars = str.toCharArray();
Arrays.sort(chars);
```
## 50. Pow(x, n)
快速幂算法

## 53. 最大子序和(贪心)
数组最大的子序列的和。思路：遍历，碰见 当前值+sum < 当前值时候，让sum= 当前值

## 54. 螺旋矩阵(矩阵)
螺旋打印矩阵，控制边界即可。

## 55. *跳跃游戏1（贪心）
数组值代表能跳的距离，从第一个位置判断能否走到最后一个位置。每一个位置，都有一个能走的最远位置，判断这个位置是否大于等于当前位置。

## 56. 合并区间（）
排序，前一个区间的s 和 e 关系：(1)e < nextS, 加入结果集  (2) e > nextS, e 与 nextE的关系，去较小值

> 区间类型的题目，一般都需要排序，然后找相邻区间的关系，或者类似于括号似的，计一下数

## 57. **插入区间
有序的无重叠区间。插入一个新的区间，使得所有新区间不重叠。
考的是逻辑思路：右区间小于当前新区间的左区间，直接加入结果集，然后是处理重叠部分，最后将剩下的（左区间大于新区间的右区间）加入结果集。

## 58. 最后一个单词的长度
从后往前遍历，去除前导 空格，从不是空格的位置开始，再次从后往前遍历，计数，碰见空格停止。

## 59. 螺旋矩阵2（矩阵）

## 60. 第K个排列(规律)
阶乘先保存在数组里面
找规律，注意k是从第1个数字开始的，所以K要先减去1， 然后  k / (n-1)!   k = k % (n-1)!

## 61. 旋转数组(链表)
计算链表长度len与k的关系，能整除，不用旋转；否则 找到倒数第k+1个节点和倒数第一个节点，然后改变指针指向即可

## 62.63 不同的路径1&2(DP)
机器人位于棋盘的左上角，只能往下或者往右走，问到右下角有多少走法。
63题，方格上有障碍物。
解法：DP，按列进行，从上到下，从左往右

## 64. 最小的路径和（DP）
和62、63一样，只不过是找一条路径,路径和最小，和前面两题思路一样。

## 66. 加一
初始进位为1，从后往前加这个进位，如果进位==0，break, 查看最终进位是否为0，如果不是，说明结果位数增加。

## 67. ***二进制相加
使用两个下标，分别从两个串的尾部到头。一开始写的时候特别费劲，总想用一个索引来控制两个串，在下标的转换中遇到了不少问题。
使用两个索引，碰到串长度不一样的时候，因为是同步移动，可以通过下标是否大于零判断。

# Hard
## 4. 寻找两个正序数组的中位数

## 10. 正则表达式匹配

## 30. 串联所有单词的子串

## 32. 最长的有效括号
一个串的最长有效括号子串。
1. 栈的做法: 栈中保存下标"("入栈， ")"出栈（然后当前下标-栈顶下标作为长度，若栈为空，当前下标入栈，作为分隔点，这也是初始栈中放-1的原因）
2. DP做法，两大类情况 "()" "))"，其余的情况都为0
- i-1和i为"()"情况 dp[i] = dp[i-2]+2      
- i-1和i为 "))" 要看i-1位置的")" 匹配了多少, 且要看 i-dp[i-1]-1位置是否为 "(" 则 dp[i] = dp[i-1]（内部） + 2+ dp[i-dp[i-1]-1-1]（外部）
- 其余为0

## 37. 解数独（回溯）
难点：如何移动到下一个位置。j每次+1 当j == col的时候，i+1, 当i == row的时候，整个函数返回。
```Java
// 判断 3 X 3 下标
x = 3 * (row / 3) + i / 3;
y = 3 * (col / 3) + i % 3;
```


## 44. 通配符匹配（DP）

## 51.52. N皇后(回溯)
求N皇后的方案或者方案数目。

回溯典型题：
按row回溯，每一row有col种放法。
难点，如何剪枝（判断是否有效）：同行、同列、主、副对角线
> 对角线 行 + 列 == 常数    行 - 列 == 常数

## 65. 有效数字（自动机）
画出状态转移图，使用有限状态自动机很简单。
状态转移，表驱动：将char转换成下标，在二维数组间转移，碰见无效状态、无效操作直接返回。