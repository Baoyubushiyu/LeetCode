- *代表需要重视的程度

# Medium
## 1. 两数之和
求数组内=target的元素下标，HashMap

## 3. 无重复字符的最长子串
使用boolean[] 256做hash桶，使用双指针，前指针往前移填充hash，发现重复的话（更新结果），后指针前移，擦除hash，循环检查前指针指向的字符是否重复，重复就后指针前移，不重复就前指针前移。

## 5. **最长的回文子串
DP, 二维DP，填左半边，从下往上，从左往右 子串 dp[i, j] = (char_i == char_j) && dp[i+1, j-1]
```Java
for (int i = len-1; i >= 0; i--) {
    for (int j = i+1; j < len; j++) {
        if (s.charAt(i) == s.charAt(j) && (i+1 > j-1 || dp[i+1][j-1])) {
            dp[i][j] = true;
            if (j-i+1 > longest) {
                longest = j - i + 1;
                start = i;
            }
        }
    }
}
```
## 6. Z字形变换
Z字形（从上到下，从左到右排列字符串，然后按行收集），关键：控制打印方向 flag 

## 7. 整数反转
直接使用取余即可，不用区分正数负数，负数对10取余，是末尾的数字加个负号（Java是截断除法），判断溢出可以判断在ret*10+last前面判断与MAX_VALUE/10的关系。

## 8. atoi字符串转整数（未做）
溢出需要全面考虑

## 9. 回文数
不将整数转化成字符串，按照第7题，将数字反转，看看是否和原数字一样。

## 11. *盛最多水的容器
双指针，头尾各一个指针，一开始宽是最长的，所以移动短的那一端，高才有可能增加，进而面积才有可能增加。

## 12. 13 罗马数字和整型的互相转化（未做）

## 14. 最长的公共前缀
字符串数组中的最长公共前缀。很简单，索引从0开始到 最短字符串的长度len，然后遍历每个串，求当前索引位置的字符是否都相等，遇到不相等的，直接返回（公共前缀就到此）。

## 15. 三数之和
固定一个数字，然后就转化成了两数之和问题，可以使用排序+双指针写法；或者使用Hash方法。

# Hard
## 4. 寻找两个正序数组的中位数

## 10. 正则表达式匹配
